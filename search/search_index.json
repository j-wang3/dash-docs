{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dash","text":"<p>A collection of core utilities expanding the capabilities of Lua in Roblox.</p> <ul> <li>View the source</li> <li>API Reference</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Disclaimer: These are not the official docs and the new functions are not available for use. It would be nice if someone helped me add them though.</p>"},{"location":"api/#types","title":"Types","text":""},{"location":"api/#array","title":"Array","text":"<pre><code>type Array&lt;Value&gt; = {[number]: Value}\n</code></pre> <p>A table with values of type Value and numeric keys 1..n with no gaps</p>"},{"location":"api/#args","title":"Args","text":"<pre><code>type Args&lt;Value&gt; = {[number]: Value}\n</code></pre> <p>A table with values of type Value and numeric keys, possibly with gaps.</p>"},{"location":"api/#map","title":"Map","text":"<pre><code>Map&lt;Key, Value&gt; = {[Key]: Value}\n</code></pre> <p>A table with keys of type Key and values of type Value</p>"},{"location":"api/#set","title":"Set","text":"<pre><code>type Set&lt;Key&gt; = {[Key]: boolean}\n</code></pre> <p>A table with keys of a fixed type Key and a boolean value representing membership of the set (default is false)</p>"},{"location":"api/#table","title":"Table","text":"<pre><code>type Table = {[any]: any}\n</code></pre> <p>A table of any type</p>"},{"location":"api/#class","title":"Class","text":"<pre><code>type Class&lt;Object&gt; = {\n\nnew: () -&gt; Object\n}\n</code></pre> <p>A class has a constructor returning an instance of Object type</p>"},{"location":"api/#handlers","title":"Handlers","text":"<p>Some functions such as filter will require handlers. There will be a <code>Key</code> and <code>Value</code> type to denote whether the key or value argument is passed first, but they are both <code>any</code> type unless otherwise specified.</p>"},{"location":"api/#anyfunction","title":"AnyFunction","text":"<pre><code>type AnyFunction = () -&gt; any\n</code></pre> <p>Represents a function which takes any arguments and returns any value</p>"},{"location":"api/#tables","title":"Tables","text":"<p>These utilities operate on Tables of any kind.</p>"},{"location":"api/#all-new","title":"all (new!)","text":"<p> Tables </p> <pre><code>type AllHandler = (Value, Key) -&gt; boolean\n\nall(input: types.Table, handler: AllHandler?): boolean\n</code></pre> <p>Iterates through all elements of the input Table.</p> <p>Calls the handler for each entry and returns <code>false</code> if the handler returns falsy for any element which it is called with. Otherwise, all elements were truthy so return <code>true</code>.</p> <p>If the handler is not provided, use the truthiness of the values in the table.</p> <p>Examples</p> <pre><code>-- These are the only falsy values in Lua\nDash.all({nil, false}) --&gt; false\n</code></pre> <pre><code>Dash.all({true, 0, \"0\"}) --&gt; true\n</code></pre> <pre><code>-- Do all words start with 'ro'?\nDash.all(\n    {\"roblox\", \"roact\", \"rodux\"}, \n    function(word) return Dash.startsWith(word, \"ro\") \nend)\n--[[\nOutput: true\n]]\n\n</code></pre>"},{"location":"api/#collect","title":"collect","text":"<p> Tables </p> <pre><code>type CollectHandler = (Key, Value) -&gt; (any, any)?\n\ncollect(input: Types.Table, handler: CollectHandler): Types.Map&lt;any, any&gt;\n</code></pre> <p>Collect returns a new Table derived from input by iterating through its pairs and calling the handler on each <code>(key, value)</code> tuple.</p> <p>The handler should return a new <code>(newKey, value)</code> tuple to be inserted into the returned Table, or <code>nil</code> if no value should be added.</p> <p>Example</p> <pre><code>-- Invert keys and values of a table\nDash.collect({a = \"1\", b = \"2\", c = 3}, function(key, value) \n    return value, key \nend)\n\n--[[\nOutput: {\n    [3] = \"c\"\n    [\"1\"] = \"a\", \n    [\"2\"] = \"b\", \n}\n]]\n</code></pre>"},{"location":"api/#collectarray","title":"collectArray","text":"<p> Tables </p> <pre><code>type CollectHandler = (Key, Value) -&gt; any?\n\ncollectArray(input: Types.Table, handler: Types.AnyFunction): Types.Array&lt;any&gt;\n</code></pre> <p>Collect returns a new Array derived from input by iterating through its pairs and calling the handler on each <code>(key, value)</code> tuple.</p> <p>The handler should return a new value to be pushed onto the end of the result array, or <code>nil</code> if no value should be added.</p> <p>Example</p> <pre><code>-- Double all elements, ignoring results that are multiples of three\nDash.collectArray({1, 2, 3, 4, 5, 6}, function(key, value)\n    local newValue = value * 2\n    return if newValue % 3 == 0 then nil else newValue\nend)\n\n--[[\nOutput: {\n[1] = 2,\n[2] = 4,\n[3] = 8,\n[4] = 10\n}\n]]\n</code></pre>"},{"location":"api/#collectset","title":"collectSet","text":"<p> Tables </p> <pre><code>type CollectHandler = (Key, Value) -&gt; any?\n\ncollectSet(input: Types.Table, handler: Types.AnyFunction?): Types.Set&lt;any&gt;\n</code></pre> <p>Build a set from the entries of the input Table, calling handler on each entry and using the returned value as an element to add to the set.</p> <p>If handler is not provided, values of <code>input</code> are used as elements.</p> <p>Examples</p> <pre><code>-- Convert Array to Set\nDash.collectSet({\"toast\", \"bagel\", \"donut\"})\n\n--[[\nOutput: {\n    [\"bagel\"] = true,\n    [\"donut\"] = true,\n    [\"toast\"] = true\n}\n]]\n</code></pre> <pre><code>-- Create set of first letters of each word\nDash.collectSet({\"toast\", \"bagel\", \"donut\", \"bread\"}, function(key, value)\n    return value:sub(1, 1)\nend)\n\n--[[\nOutput: {\n    [\"b\"] = true,\n    [\"d\"] = true,\n    [\"t\"] = true\n}\n]]\n</code></pre>"},{"location":"api/#copy","title":"copy","text":"<p> Tables </p> <pre><code>copy(input: Types.Table): Types.Table\n</code></pre> <p>Returns a shallow copy of the input Table.</p> <p>Example</p> <pre><code>Dash.copy({a = 1, b = 3})\n\n--[[\nOutput: {\n    [\"a\"] = 1,\n    [\"b\"] = 3\n}\n]]\n</code></pre>"},{"location":"api/#count-new","title":"count (new!)","text":"<p> Tables </p> <pre><code>type CountHandler = (Value, Key) -&gt; boolean\n\ncount(input: types.Table, handler: CountHandler?): number\n</code></pre> <p>If no handler is provided, return the number of elements in the input Table.</p> <p>If the handler is provided, increase the count for each element for which the handler returns true on the <code>(value, key)</code> pair.</p> <p>Examples</p> <pre><code>Dash.count({1, 2, 3, 4, 5}) --&gt; 5\n</code></pre> <pre><code>-- Count the number of ids that start with 1\nDash.count(\n    {[12] = true, [24] = true, [153] = true, [199] = true}, \n    function(value, id) return tostring(id):sub(1, 1) == \"1\" \nend)\n\n--[[\nOutput: 3\n]]\n</code></pre> <pre><code>-- Count the number of numbers divisible by 5\nDash.count(\n    {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}, \n    function(num) return num % 5 == 0\nend)\n\n--[[\nOutput: 2\n]]\n</code></pre>"},{"location":"api/#filter","title":"filter","text":"<p> Tables </p> <pre><code>type FilterHandler = (Value, Key) -&gt; boolean\n\nfilter(input: Types.Table, handler: FilterHandler): Types.Array&lt;any&gt;\n</code></pre> <p>Filter the input Table by calling the handler on each <code>(value, key)</code> tuple.</p> <p>For an Array input, the order of elements is preserved in the output.</p> <p>The handler should return truthy to preserve the value in the resulting Table.</p> <p>Example</p> <pre><code>-- Take only the elements whose values begin with \"r\"\nDash.filter(\n    {place = \"roblox\", packages = \"rotriever\", ide = \"studio\"}, \n    function(word) return Dash.startsWith(word, \"r\") \nend)\n\n--[[\nOutput: {\n    [1] = \"roblox\",\n    [2] = \"rotriever\"\n}\n]]\n</code></pre> <p>TODO: Why does this return an Array? It can be made to return a Table.</p>"},{"location":"api/#find","title":"find","text":"<p> Tables </p> <pre><code>type FindHandler = (Value, Key) -&gt; boolean\n\nfind(input: Types.Table, handler: FindHandler) -&gt; value?\n</code></pre> <p>Returns an element in the input Table that the handler returns <code>true</code> for, when passed the <code>(value, key)</code> entry.</p> <p>Returns nil if no entires satisfy the condition.</p> <p>For an Array, this first matching element is returned. For a Map, an arbitrary matching element is returned if it exists.</p> <p>Examples</p> <pre><code>-- Check if there's the \"ExtraSettings\" key and get the value of that key if so\nDash.find(\n    {Id = 145, IsReady = false, ExtraSettings = {AutoReady = true}}, \n    function(value, key) return key == \"ExtraSettings\" end\n)\n\n--[[\nOutput: {\n    [\"AutoReady\"] = true\n}\n]]\n\n\nDash.find({Id = 145, IsReady = false}, \n    function(value, key) return key == \"ExtraSettings\" end\n)\n--[[\nOutput: nil\n]]\n\n</code></pre> <p>See</p> <ul> <li>Dash.first for a function which returns the first element of an Array matching a condition.</li> </ul>"},{"location":"api/#foreach","title":"forEach","text":"<p> Tables </p> <pre><code>type ForEachHandler = (Value, Key) -&gt; ()\n\nforEach(input: Types.Table, handler: ForEachHandler): ()\n</code></pre> <p>Iterates through the elements of the input Table.</p> <p>If the table is an Array, it iterates in order 1..n.</p> <p>If the table is a Map, the keys are visited in an arbitrary order.</p> <p>Calls the handler for each entry.</p> <p>Example</p> <pre><code>-- Print all values of table\nDash.forEach({\"Item 1\", \"Item 2\", \"Item 3\"}, function(value) print(value) end)\n\n--[[\nOutput: Item 1\nItem 2\nItem 3  \n]]\n</code></pre>"},{"location":"api/#frequencies-new","title":"frequencies (new!)","text":"<p> Tables </p> <pre><code>type FrequenciesHandler = (Value, Key) -&gt; any\n\nfrequencies(input: Types.Table)\n</code></pre> <p>If no handler is provided, returns a Map with keys as unique values of the input Table and values as the count of each value.</p> <p>If a handler is provided, returns a Map with keys as unique elements given by the handler and values as the count of each mapped key.</p> <p>Examples</p> <pre><code>Dash.frequencies({\"Red\", \"Black\", \"Orange\", \"Red\"})\n\n--[[\nOutput:{\n    [\"Black\"] = 1,\n    [\"Orange\"] = 1,\n    [\"Red\"] = 2\n} \n]]\n</code></pre> <pre><code>-- Count colors by simple definition of neutral and non-neutral\nfunction toNeutral(color) \n    return if Dash.includes({\"Black\", \"Gray\", \"White\"}, color) \n        then \"Neutral\" \n        else \"Non-neutral\"\nend\nDash.frequencies(\n    {\"Black\", \"Orange\", \"Blue\", \"Gray\", \"White\"}, \n    function(color) return toNeutral(color) \nend)\n\n--[[\nOutput: {\n    [\"Neutral\"] = 3,\n    [\"Non-neutral\"] = 2\n}\n]]\n</code></pre>"},{"location":"api/#groupby","title":"groupBy","text":"<p> Tables </p> <pre><code>groupBy(input: Types.Table, getKey: any): Types.Table\n</code></pre> <p>Groups values in the input Table by their getKey value.</p> <p>Each value of the result Table is an Array of values from the input Table which were assigned the corresponding key.</p> <p>If getKey is a function, it is called with each <code>(value, key)</code> entry and uses the return value as the corresponding key to insert at in the result Table. Otherwise, the getKey value is used directly as the key itself.</p> <p>Example</p> <pre><code>local output = groupBy({\n    bike = {\n        name = \"bike\",\n        color = \"blue\"\n    },\n    car = {\n        name = \"car\",\n        color = \"red\"\n    },\n    van = {\n        name = \"van\",\n        color = \"white\"\n    },\n    ghost = {\n        name = \"ghost\"\n    }\n}, \"color\")\n--[[\nOutput: {\n    blue = {\n        {\n            color = \"blue\",\n            name = \"bike\"\n        }\n    },\n    red = {\n        {\n            color = \"red\",\n            name = \"car\"\n        }\n    },\n    white = {\n        {\n            color = \"white\",\n            name = \"van\"\n        }\n    }\n}\n]]\n</code></pre>"},{"location":"api/#includes","title":"includes","text":"<p> Tables </p> <pre><code>includes(source: Types.Table, value: any): boolean\n</code></pre> <p>Returns true if the item exists as a value in the source Table.</p> <p>Example</p> <pre><code>-- Does the table include 100?\nDash.includes({1, 10, 100, 1000}, 100)\n\n--[[\nOutput: true\n]]\n</code></pre> <p>See</p> <p>For a stronger version of <code>Dash.includes</code>, use Dash.some.</p>"},{"location":"api/#keyby","title":"keyBy","text":"<p> Tables </p> <pre><code>keyBy(input: Types.Table, getKey: any): Types.Table\n</code></pre> <p>Assigns values in the input Table by their getKey value.</p> <p>If getKey is a function, it is called with each <code>(value, key)</code> entry and uses the return value as the corresponding key to assign to in the result Table. Otherwise, the getKey value is used directly as the key itself.</p> <p>Example</p> <pre><code>local output = keyBy({\n    bike = {\n        name = \"bike\",\n        color = \"blue\"\n    },\n    car = {\n        name = \"car\",\n        color = \"red\"\n    },\n    van = {\n        name = \"van\",\n        color = \"white\"\n    },\n    ghost = {\n        name = \"ghost\"\n    }\n}, \"color\")\n[[\nOutput: {\n    blue = {\n        color = \"blue\",\n        name = \"bike\"\n    },\n    red = {\n        color = \"red\",\n        name = \"car\"\n    },\n    white = {\n        color = \"white\",\n        name = \"van\"\n    }\n}]]\n</code></pre>"},{"location":"api/#keys","title":"keys","text":"<p> Tables </p> <pre><code>keys(input: Types.Table): Types.Array&lt;any&gt;\n</code></pre> <p>Returns an Array of the keys in the input Table.</p> <p>If the input is an Array, ordering is preserved.</p> <p>If the input is a Map, elements are keys in an arbitrary order.</p> <p>Example:</p> <pre><code>Dash.keys({\n    Color = \"Purple\",\n    Type = \"Fruit\",\n    Shape = \"Round\"\n})\n\n--[[\nOutput: {\n    [1] = \"Color\",\n    [2] = \"Type\",\n    [3] = \"Shape\"\n}\n]]\n</code></pre>"},{"location":"api/#map_1","title":"map","text":"<p> Tables </p> <pre><code>type MapHandler = (Value, Key) -&gt; any\n\nmap(input: Types.Table, handler: MapHandler): Types.Table\n</code></pre> <p>Iterates through the elements of the input Table.</p> <p>For an Array input, the elements are visted in order 1..n.</p> <p>For a Map input, the elements are visited in an arbitrary order.</p> <p>Calls the handler for each entry and constructs a new Table using the same keys but replacing the values with new ones returned from the handler.</p> <p>Values returned by handler must be defined.</p> <p>Example</p> <pre><code>-- Map characters to their ASCII\nDash.map({\"a\", \"b\", \"c\"}, function(char) return string.byte(char) end)\n\n--[[\nOutput: {\n    [1] = 97,\n    [2] = 98,\n    [3] = 99\n}\n]]\n</code></pre> <p>See</p> <ul> <li>Dash.collectArray if you want to return nil values.</li> </ul>"},{"location":"api/#mapone","title":"mapOne","text":"<p> Arrays </p> <pre><code>type MapHandler = (Value, Key) -&gt; any?\n\nmapOne(input: Types.Table, handler: MapHandler?)\n</code></pre> <p>Iterates through the elements of the input Table in no particular order.</p> <p>Calls the handler for each entry and returns the first non-nil value returned by the handler.</p> <p>If handler is <code>nil</code>, the first value visited is returned.</p> <p>Example</p> <pre><code>-- Get any message that's not hidden and return its id.\nDash.mapOne({\n    {Id = 1, IsHidden = true},\n    {Id = 3, IsHidden = false},\n    {Id = 2, IsHidden = false},\n}, function(message) \n    return if message.IsHidden then nil else message.Id \nend)\n\n--[[\nOutput: 3\n]]\n</code></pre>"},{"location":"api/#max-new","title":"max (new!)","text":"<p> Tables </p> <pre><code>type MaxComparator = (any, any) -&gt; boolean\ntype MaxHandler = (Value, Key) -&gt; any\n\nmax(input: Types.Table, handler: MaxHandler?, comparator: MaxComparator): any\n</code></pre> <p>Returns the maximum value in the input Table. By default, this returns the greatest value in the table as defined by the <code>&gt;</code> operator.</p> <p>If a handler is provided, elements will first be transformed by <code>handler(value, key)</code> before being used for comparison.</p> <p>Elements will be compared using the comparator if it is provided. The comparator should take two elements and return <code>true</code> if the first one is greater than the second one, and <code>false</code> otherwise.</p> <p>If the provided input has no elements, return <code>nil</code>.</p> <p>Examples</p> <pre><code>Dash.max({1, 2, 3}) --&gt; 3\n</code></pre> <pre><code>Dash.max({\"1\", \"2\", \"10\"}) --&gt; \"2\"\n</code></pre> <pre><code>Dash.max({1, 2, 3}, function(num) return -num end) --&gt; 1\n</code></pre> <pre><code>Dash.max(\n    {\"blue\", \"red\", \"orange\"}, \n    nil, \n    function(word1, word2) return word1:len() &gt; word2:len() end\n) --&gt; \"orange\"\n</code></pre>"},{"location":"api/#min-new","title":"min (new!)","text":"<p> Table </p> <pre><code>type MinComparator = (any, any) -&gt; boolean\ntype MinHandler = (Value, Key) -&gt; any\n\nmin(input: Types.Table, handler: MinHandler?, comparator: MinComparator): any\n</code></pre> <p>Returns the minimum value in the input Table. By default, this returns the least value in the table as defined by the <code>&lt;</code> operator.</p> <p>If a handler is provided, elements will first be transformed by <code>handler(value, key)</code> before being used for comparison.</p> <p>Elements will be compared using the comparator if it is provided. The comparator should take two elements and return <code>true</code> if the first one is less than the second one, and <code>false</code> otherwise.</p> <p>If the provided input has no elements, return <code>nil</code>.</p> <p>Examples</p> <pre><code>Dash.min({1, 2, 3}) --&gt; 1\n</code></pre> <pre><code>Dash.min({\"2\", \"20\", \"10\"}) --&gt; \"10\"\n</code></pre> <pre><code>Dash.min({3, 2, 1}, function(num) return -num end) --&gt; 3\n</code></pre> <pre><code>Dash.min(\n    {\"blue\", \"red\", \"orange\"}, \n    nil, \n    function(word1, word2) return word1:len() &lt; word2:len() end\n) --&gt; \"red\"\n</code></pre>"},{"location":"api/#omit","title":"omit","text":"<p> Tables </p> <pre><code>omit(input: Types.Table, keys: Types.Array&lt;any&gt;): Types.Table\n</code></pre> <p>Return a new Table made from entries in the input Table whose key is not in the keys Array.</p> <p>If the input is an Array, ordering is preserved.</p> <p>If the input is a Map, elements are returned in an arbitrary order.</p> <p>Example</p> <pre><code>-- Remove the ShouldShow key/value pair from the table\nDash.omit({\n    ShouldShow = true,\n    Text = \"Hello World!\",\n    Title = \"Greetings!\",\n}, {\"ShouldShow\"})\n\n--[[\nOutput: {\n    [\"Text\"] = \"Hello World!\",\n    [\"Title\"] = \"Greetings!\"\n}\n]]\n</code></pre>"},{"location":"api/#reduce","title":"reduce","text":"<p> Tables </p> <pre><code>type Accumulator = any\n\ntype ReduceHandler = (Accumulator, Value, Key) -&gt; Accumulator\n\nreduce(input: Types.Table, handler: ReduceHandler, initial: Accumulator)\n</code></pre> <p>Iterate through the elements of the input Table, preserving order if it is an Array.</p> <p>Call the handler for each element, passing the return of the previous call as the first argument.</p> <p>The initial value is passed into the first call, and the final value returned by the function.</p> <p>Examples</p> <pre><code>-- Count occurences of each element in array and output a table of counts\n-- See Dash.frequencies\nDash.reduce(\n    {\"Red\", \"Black\", \"Red\", \"Red\", \"Black\"}, \n    function(acc, color)\n        if acc[color] == nil then\n            acc[color] = 1\n        else\n            acc[color] += 1\n        end\n        return acc\n    end, {}\n)\n\n--[[\nOutput: {\n    [\"Black\"] = 2,\n    [\"Red\"] = 3\n} \n]]\n</code></pre> <pre><code>-- Sum up elements, doubling even indices and halving odd indices\n-- Expected: 0.5 + 4 + 1.5 + 8 + 2.5 = 16.5\nDash.reduce(\n    {1, 2, 3, 4, 5},\n    function(acc, num, index)\n        return acc + if index % 2 == 0 then num * 2 else num / 2\n    end, 0\n)\n--[[\nOutput: 16.5\n]]\n</code></pre>"},{"location":"api/#shallowequal","title":"shallowEqual","text":"<p> Tables </p> <pre><code>shallowEqual(left: any, right: any): boolean\n</code></pre> <p>Returns <code>true</code> if the left and right values are equal (by the equality operator) or the inputs are tables, and all their keys are equal.</p> <p>Examples</p> <pre><code>Dash.shallowEqual({\n    A = 1, \n    B = 2\n}, {\n    A = 1,\n    B = 2,\n})\n\n--[[\nOutput: true\n]]\n</code></pre> <pre><code>Dash.shallowEqual({\n    A = 1, \n    B = 2,\n    C = 3\n}, {\n    A = 1,\n    B = 2,\n    D = 3\n})\n\n--[[\nOutput: false\n]]\n</code></pre>"},{"location":"api/#some","title":"some","text":"<p> Tables </p> <pre><code>type SomeHandler = (Value, Key) -&gt; boolean\n\nsome(input: Types.Map&lt;Key, Value&gt;, handler: SomeHandler): boolean\n</code></pre> <p>Iterates through the elements of the input Table in no particular order.</p> <p>Calls the handler for each entry and returns <code>true</code> if the handler returns truthy for any element which it is called with.</p> <p>Example</p> <pre><code>-- Does there exist a red fruit?\nDash.some(\n    {\n        {Type = \"Cherry\", Color = \"Red\"}, \n        {Type = \"Strawberry\", Color = \"Red\"}, \n        {Type = \"Blueberry\", Color = \"Blue\"}\n    }, \n    function(fruit) return fruit.Color == \"Red\" end\n)\n\n--[[\nOutput: true\n]]\n</code></pre>"},{"location":"api/#values","title":"values","text":"<p> Tables </p> <pre><code>values(input: Types.Map&lt;any, any&gt;): Types.Array&lt;any&gt;\n</code></pre> <p>Returns an Array of the values in the input Table.</p> <p>If the input is an Array, ordering is preserved.</p> <p>If the input is a Map, values are returned in an arbitrary order.</p> <p>Example</p> <pre><code>Dash.values({\n    Type = \"Cherry\", \n    Color = \"Red\", \n    Price = \"Expensive\", \n    EnjoymentLevel = \"High\"\n})\n\n--[[\nOutput: {\n    [1] = \"Red\",\n    [2] = \"Cherry\",\n    [3] = \"High\",\n    [4] = \"Expensive\"\n}\n]]\n</code></pre>"},{"location":"api/#arrays","title":"Arrays","text":"<p>These utilities operate on Arrays, tables with ordered keys 1..n.</p>"},{"location":"api/#append","title":"append","text":"<p> Mutable | Arrays </p> <pre><code>append&lt;T&gt;(target: Types.Array&lt;T&gt;, ...: Types.Array&lt;T&gt;): Types.Array&lt;T&gt;\n</code></pre> <p>Adds new elements to the target Array from subsequent Array arguments in left-to-right order.</p> <p>Arguments which are <code>nil</code> or None are skipped.</p> <p>Example</p> <pre><code>Dash.append({1, 2}, {3, 4}, {5})\n\n--[[\nOutput: {\n    [1] = 1,\n    [2] = 2,\n    [3] = 3,\n    [4] = 4,\n    [5] = 5\n}\n]]\n</code></pre>"},{"location":"api/#findindex","title":"findIndex","text":"<p> Arrays </p> <pre><code>type FindHandler = (Value, Key) -&gt; boolean\n\nfindIndex(input: Types.Array&lt;any&gt;, handler: FindHandler): value?\n</code></pre> <p>Returns the index of the first element in the input Array that the handler returns <code>true</code> for, when passed the <code>(value, key)</code> entry.</p> <p>Returns nil if no entires satisfy the condition.</p> <p>Examples</p> <pre><code>-- Find index of \"Clementine\" fruit if it exists in the Array\nDash.findIndex(\n    {\"Apple\", \"Banana\", \"Clementine\"}, \n    function(fruit) return fruit == \"Clementine\" end\n)\n\n--[[\nOutput: 3\n]]\n</code></pre> <pre><code>Dash.findIndex(\n    {\"Apple\", \"Banana\"}, \n    function(fruit) return fruit == \"Clementine\" end\n)\n\n--[[\nOutput: nil\n]]\n</code></pre>"},{"location":"api/#flat","title":"flat","text":"<p> Arrays </p> <pre><code>flat(input: Types.Array&lt;Types.Array&lt;any&gt;&gt;): Types.Array&lt;any&gt;\n</code></pre> <p>Flattens the input array by a single level. Outputs a new Array of elements merged from the input Array arguments in left-to-right order.</p> <p>Example</p> <pre><code>-- Flatten a partition of numbers in the range 1-5\nDash.flat({\n    {1, 2, 3}, \n    {4, 5}\n})\n\n--[[\nOutput:  {\n    [1] = 1,\n    [2] = 2,\n    [3] = 3,\n    [4] = 4,\n    [5] = 5\n}\n]]\n</code></pre>"},{"location":"api/#last","title":"last","text":"<p> Arrays </p> <pre><code>type FindHandler = (Value, Key) -&gt; boolean\n\nlast(input: Types.Table, handler: FindHandler?): Value?\n</code></pre> <p>Returns the last element in the input Array that the handler returns <code>true</code> for, when passed the <code>(value, key)</code> entry.</p> <p>Returns nil if no entires satisfy the condition.</p> <p>If handler is not defined, the function simply returns the last element of the Array.</p> <p>Examples</p> <pre><code>Dash.last({3, 2, 1})\n\n--[[\nOutput: 1\n]]\n</code></pre> <pre><code>-- Get last odd number\nDash.last({4, 3, 2}, function(num) return num % 2 == 1 end)\n\n--[[\nOutput: 3\n]]\n</code></pre>"},{"location":"api/#mapfirst","title":"mapFirst","text":"<p> Arrays </p> <pre><code>type MapHandler = (Value, Key) -&gt; any?\n\nmapFirst(input: Types.Array&lt;any&gt;, handler: MapHandler)\n</code></pre> <p>Iterates through the elements of the input Array in order 1..n.</p> <p>Calls the handler for each entry and returns the first non-nil value returned by the handler.</p> <p>Example</p> <pre><code>-- Get first color that's 6 letters and return its first letter\nDash.mapFirst(\n    {\"Red\", \"Yellow\", \"Orange\", \"Blue\"}, \n    function(color)\n        return if color:len() == 6 then color:sub(1, 1) else nil\n    end\n)\n\n--[[\nOutput: Y\n]]\n</code></pre>"},{"location":"api/#maplast","title":"mapLast","text":"<p> Arrays </p> <pre><code>type MapHandler = (Value, Key) -&gt; any?\n\nmapLast(input: Types.Array&lt;any&gt;, handler: MapHandler)\n</code></pre> <p>Iterates through the elements of the input Array in reverse in order n..1.</p> <p>Calls the handler for each entry and returns the first non-nil value returned by the handler.</p> <p>Example</p> <pre><code>-- Get last color that's 6 letters and return its first letter\nDash.mapLast(\n    {\"Red\", \"Yellow\", \"Orange\", \"Blue\"}, \n    function(color)\n        return if color:len() == 6 then color:sub(1, 1) else nil\n    end\n)\n\n--[[\nOutput: O\n]]\n</code></pre>"},{"location":"api/#product-new","title":"product (new!)","text":"<p> Arrays </p> <pre><code>product(input: Types.Array&lt;number&gt;): number\n</code></pre> <p>Multiplies together all of the numbers in the input Array.</p> <p>If the input has no elements, return <code>1</code>.</p> <p>Example</p> <pre><code>Dash.product({3, 3, 2}) --&gt; 18\n</code></pre>"},{"location":"api/#reverse","title":"reverse","text":"<p> Arrays </p> <pre><code>reverse(input: Types.Array&lt;any&gt;): Types.Array&lt;any&gt;\n</code></pre> <p>Reverse the order of the elements in the input Array.</p> <p>Example</p> <pre><code>Dash.reverse({3, 2, 1})\n\n--[[\nOutput: {\n    [1] = 1,\n    [2] = 2,\n    [3] = 3\n}\n]]\n</code></pre>"},{"location":"api/#slice","title":"slice","text":"<p> Arrays </p> <pre><code>slice(input: Types.Array&lt;any&gt;, left: number?, right: number?): Types.Array&lt;any&gt;\n</code></pre> <p>Return a portion of the input Array starting with the element at the left index and ending with the element at the right index (i.e. an inclusive range)</p> <p>If left is not defined, it defaults to 1. If right is not defined, it defaults to the length of the array (i.e. the last element)</p> <p>If left is <code>-n</code>, the slice starts with the element <code>n</code> places from the last one. If right is <code>-n</code>, the slice ends with the element <code>n</code> places from the last one.</p> <p>An empty array is returned if the slice has no or negative length.</p> <p>Examples</p> <pre><code>Dash.slice({1, 2, 3, 4, 5}, 2, 4)\n\n--[[\nOutput: {\n    [1] = 2,\n    [2] = 3,\n    [3] = 4\n}\n]]\n</code></pre> <pre><code>Dash.slice({1, 2, 3, 4, 5}, 3)\n\n--[[\nOutput: {\n    [1] = 3,\n    [2] = 4,\n    [3] = 5\n}\n]]\n</code></pre> <pre><code>Dash.slice({1, 2, 3, 4, 5}, nil, -1)\n\n--[[\nOutput: {\n    [1] = 1,\n    [2] = 2,\n    [3] = 3,\n    [4] = 4\n}\n]]\n</code></pre>"},{"location":"api/#sum-new","title":"sum (new!)","text":"<p> Arrays </p> <pre><code>sum(input: Types.Array&lt;number&gt;): number\n</code></pre> <p>Adds together all of the numbers in the input Array.</p> <p>If the input Array has no elements, return <code>0</code>.</p> <p>Example</p> <pre><code>Dash.sum({3, 2, 1}) --&gt; 6\n</code></pre>"},{"location":"api/#maps","title":"Maps","text":"<p>These utilities operate on Maps, tables with arbitrary keys.</p>"},{"location":"api/#assign","title":"assign","text":"<p> Mutable | Maps </p> <pre><code>assign(target: Types.Table, ...: Args&lt;Table&gt;): Types.Table\n</code></pre> <p>Adds new values to target from subsequent Table arguments in left-to-right order.</p> <p>Examples</p> <pre><code>local characters = {\n    Frodo = {\n        name = \"Frodo Baggins\",\n        team = \"blue\"\n    },\n    Boromir = {\n        score = 5\n    }\n}\nlocal otherCharacters = {\n    Frodo = {\n        team = \"red\",\n        score = 10\n    },\n    Bilbo = {\n        team = \"yellow\",\n    },\n    Boromir = {\n        score = {1, 2, 3}\n    }\n}\nlocal result = assign(characters, otherCharacters)\nprint(result) --[[\n--&gt; {\n    Frodo = {\n        team = \"red\",\n        score = 10\n    },\n    Bilbo = {\n        team = \"yellow\"\n    },\n    Boromir = {\n        score = {1, 2, 3}\n    }\n}\n]]\n</code></pre> <p>See</p> <ul> <li>Dash.join for an immutable alternative</li> </ul>"},{"location":"api/#freeze","title":"freeze","text":"<p> Maps </p> <pre><code>freeze(objectName: string, object: Types.Table, throwIfMissing: boolean?): Types.Table\n</code></pre> <p>Returns a new read-only view of object which prevents any values from being changed.</p> <p>Parameters</p> Name Description <code>name</code> The name of the object for improved error message readability. <code>throwIfMissing</code> If <code>true</code> then access to a missing key will also throw. <p>Notes</p> <p>Unfortunately you cannot iterate using <code>pairs</code> or <code>ipairs</code> on frozen objects because Luau doesn't support defining these custom iterators in metatables.</p> <p>Example</p> <pre><code>local drink = freeze(\"Ice Cream\", {\n    flavor = \"mint\",\n    topping = \"sprinkles\"\n}, true)\nprint(drink.flavor) --&gt; \"mint\"\ndrink.flavor = \"vanilla\"\n--!&gt; ReadonlyKey: Attempt to write to readonly key \"flavor\" (a string) of frozen object \"Ice Cream\"\nprint(drink.syrup) --&gt; nil\n--!&gt; MissingKey: Attempt to read missing key \"syrup\" (a string) of frozen object \"Ice Cream\"\n</code></pre>"},{"location":"api/#getorset","title":"getOrSet","text":"<p> Maps </p> <pre><code>type GetValueHandler = (Types.Table, Key) -&gt; Value\n\ngetOrSet(input: Types.Table, key: Key, getValue: GetValueHandler): Value\n</code></pre> <p>Returns a value of the input Table at the key provided. If the key is missing, the value is acquired from the getValue handler, added to the input Table and returned.</p> <p>Examples</p> <pre><code>Dash.getOrSet(\n    {Item = \"Gummy Bear\", Color = \"Lime\"}, \n    \"Color\", \n    function() return \"Yellow\" end\n)\n\n--[[\nOutput: Lime\n]]\n</code></pre> <pre><code>Dash.getOrSet(\n    {Item = \"Gummy Bear\"}, \n    \"Color\", \n    function() return \"Yellow\" end\n)\n\n--[[\nOutput: Yellow\n]]\n</code></pre>"},{"location":"api/#join","title":"join","text":"<p> Maps </p> <pre><code>join(...): Types.Map&lt;any, any&gt;\n</code></pre> <p>Output a new Map from merging all the keys in the Map arguments in left-to-right order.</p> <p>Example</p> <pre><code>Dash.join(\n    {Text = \"Hello World!\", Color = \"Sky Blue\"}, \n    {Title = \"Greetings!\", Color = \"Indigo\"}\n)\n\n--[[\nOutput: {\n    [\"Color\"] = \"Indigo\",\n    [\"Text\"] = \"Hello World!\",\n    [\"Title\"] = \"Greetings!\"\n} \n]]\n</code></pre> <p>See</p> <ul> <li>Dash.assign for a mutable alternative</li> </ul>"},{"location":"api/#joindeep","title":"joinDeep","text":"<p> Maps </p> <pre><code>joinDeep(source: Types.Map&lt;any, any&gt;, delta: Types.Map&lt;any, any&gt;): Types.Map&lt;any, any&gt;\n</code></pre> <p>Creates a shallow clone of the source Map, and copies the values from the delta Map by key, like the join utility.</p> <p>However, if any of the values are tables themselves, the joinDeep function is called recursively to produce a new table at the specified key.</p> <p>The purpose of this function is to merge nested immutable data using as few table creation operations as possible, making it appropriate for updating state in a reducer.</p> <p>Usage</p> <ul> <li>The None symbol can be used to remove an existing value.</li> </ul> <p>Example</p> <pre><code>local source = {\n    name = \"car\",\n    lights = {\n        front = 2,\n        back = 2,\n        indicators = {\n            color = \"orange\"\n        },\n        brake = {\n            color = \"red\"\n        }\n    },\n    tyres = 4\n}\nlocal delta = {\n    name = \"bike\",\n    lights = {\n        front = 3,\n        indicators = {\n            rate = 20\n        }\n    },\n    tyres = None\n}\nlocal output = joinDeep(source, delta)\n[[\nOutput: {\n    lights = {\n        back = 2,\n        brake = {\n            color = \"red\"\n        },\n        front = 3,\n        indicators = {\n            color = \"orange\",\n            rate = 20\n        }\n    },\n    name = \"bike\"\n}\n]]\n</code></pre>"},{"location":"api/#strings","title":"Strings","text":"<p>These utilities are helpful for working with strings.</p>"},{"location":"api/#endswith","title":"endsWith","text":"<p> Strings </p> <pre><code>endsWith(input: string, suffix: string): boolean\n</code></pre> <p>Checks if input ends with the string suffix.</p> <p>Examples</p> <pre><code>endsWith(\"Fun Roblox Games\", \"Games\") --&gt; true\n</code></pre> <pre><code>endsWith(\"Bad Roblox Memes\", \"Games\") --&gt; false\n</code></pre>"},{"location":"api/#islowercase","title":"isLowercase","text":"<p> Strings </p> <pre><code>isLowercase(input: string): boolean\n</code></pre> <p>Returns <code>true</code> if the first character of input is a lower-case character.</p> <p>Throws if the input is not a string or it is the empty string.</p> <p>Our current version of Lua unfortunately does not support upper or lower-case detection outside the english alphabet. This function has been implemented to return the expected result once this has been corrected.</p> <p>Examples</p> <pre><code>Dash.isLowercase(\"abcdef\") --&gt; true\n</code></pre> <pre><code>Dash.isLowercase(\"Title\") --&gt; false\n</code></pre>"},{"location":"api/#isuppercase","title":"isUppercase","text":"<p> Strings </p> <pre><code>isUppercase(input: string): boolean\n</code></pre> <p>Returns <code>true</code> if the first character of input is an upper-case character.</p> <p>Throws if the input is not a string or it is the empty string.</p> <p>Our current version of Lua unfortunately does not support upper or lower-case detection outside the english alphabet. This function has been implemented to return the expected result once this has been corrected.</p> <p>Examples</p> <pre><code>Dash.isUppercase(\"ABCDEF\") --&gt; true\n</code></pre> <pre><code>Dash.isUppercase(\"rObLoX\") --&gt; false\n</code></pre>"},{"location":"api/#leftpad","title":"leftPad","text":"<p> Strings </p> <pre><code>leftPad(input: string, length: number, prefix: string?): string\n</code></pre> <p>Makes a string of <code>length</code> from <code>input</code> by repeating characters from <code>prefix</code> at the start of the string.</p> <p>Params</p> <ul> <li><code>prefix</code> - default = <code>\"\"</code></li> </ul> <p>Examples</p> <pre><code>leftPad(\"toast\", 6) --&gt; \" toast\"\n</code></pre> <pre><code>leftPad(\"2\", 2, \"0\") --&gt; \"02\"\n</code></pre> <pre><code>leftPad(\"toast\", 10, \":)\") --&gt; \":):):toast\"\n</code></pre>"},{"location":"api/#rightpad","title":"rightPad","text":"<p> Strings </p> <pre><code>rightPad(input: string, length: number, suffix: string?): string\n</code></pre> <p>Makes a string of <code>length</code> from <code>input</code> by repeating characters from <code>suffix</code> at the end of the string.</p> <p>By default, suffix is <code>\" \"</code>.</p> <p>Examples</p> <pre><code>rightPad(\"toast\", 6) --&gt; \"toast \"\n</code></pre> <pre><code>rightPad(\"2\", 2, \"!\") --&gt; \"2!\"\n</code></pre> <pre><code>rightPad(\"toast\", 10, \":)\") --&gt; \"toast:):):\"\n</code></pre>"},{"location":"api/#spliton","title":"splitOn","text":"<p> Strings </p> <pre><code>splitOn(input: string, pattern: string): Types.Array&lt;string&gt;\n</code></pre> <p>Splits input into parts based on a pattern delimiter and returns a Table of the parts, followed by a Table of the matched delimiters.</p> <p>Example</p> <pre><code>local parts, delimeters = Dash.splitOn(\n    \"The quick brown fox jumps over the lazy dog\", \n    \" \"\n)\n\nprint(parts)\n--[[\nOutput: {\n    [1] = \"The\",\n    [2] = \"quick\",\n    [3] = \"brown\",\n    [4] = \"fox\",\n    [5] = \"jumps\",\n    [6] = \"over\",\n    [7] = \"the\",\n    [8] = \"lazy\",\n    [9] = \"dog\"\n}\n]]\n\nprint(delimeters)\n--[[\n{\n    [1] = \" \",\n    [2] = \" \",\n    [3] = \" \",\n    [4] = \" \",\n    [5] = \" \",\n    [6] = \" \",\n    [7] = \" \",\n    [8] = \" \"\n}\n]]\n</code></pre>"},{"location":"api/#startswith","title":"startsWith","text":"<p> Strings </p> <pre><code>startsWith(input: string, prefix: string): boolean\n</code></pre> <p>Checks if input starts with the string start.</p> <p>Examples</p> <pre><code>startsWith(\"Fun Roblox Games\", \"Fun\") --&gt; true\n</code></pre> <pre><code>startsWith(\"Chess\", \"Fun\") --&gt; false\n</code></pre>"},{"location":"api/#trim","title":"trim","text":"<p> Strings </p> <pre><code>trim(input: string): string\n</code></pre> <p>Remove any whitespace at the start and end of the input string.</p> <p>Example</p> <pre><code>Dash.trim(\"\\n\\t\\rhello world   \") --&gt; \"hello world\"\n</code></pre>"},{"location":"api/#functions","title":"Functions","text":"<p>These utilities are helpful for working with functions.</p>"},{"location":"api/#compose","title":"compose","text":"<p> Functions </p> <pre><code>compose(...: Types.Array&lt;Types.AnyFunction&gt;): Types.AnyFunction\n</code></pre> <p>Returns a function that calls the argument functions in left-right order on an input, passing the return of the previous function as argument(s) to the next.</p> <p>Example</p> <pre><code>local function fry(item)\n    return \"fried \" .. item\nend\nlocal function cheesify(item)\n    return \"cheesy \" .. item\nend\nlocal prepare = compose(fry, cheesify)\nprepare(\"nachos\") --&gt; \"cheesy fried nachos\"\n</code></pre>"},{"location":"api/#foreachargs","title":"forEachArgs","text":"<p> Functions </p> <pre><code>forEachArgs(handler: Types.AnyFunction, ...: Args&lt;Value&gt;): ()\n</code></pre> <p>Iterates through the tail arguments in order, including nil values up to the argument list length.</p> <p>Calls the handler for each entry.</p>"},{"location":"api/#identity","title":"identity","text":"<p> Functions </p> <pre><code>identity(...)\n</code></pre> <p>The identity function, which simply returns its input parameters.</p> <p>Can be used to make it clear that a handler returns its inputs.</p>"},{"location":"api/#iscallable","title":"isCallable","text":"<p> Functions </p> <pre><code>isCallable(value: any): boolean\n</code></pre> <p>Returns <code>true</code> if the value can be called i.e. you can write <code>value(...)</code>.</p>"},{"location":"api/#noop","title":"noop","text":"<p> Functions </p> <pre><code>noop()\n</code></pre> <p>A function which does nothing.</p> <p>Can be used to make it clear that a handler has no function.</p>"},{"location":"api/#classes","title":"Classes","text":"<p>These utilities are helpful for working with classes.</p>"},{"location":"api/#error","title":"Error","text":"<p> Classes </p> <pre><code>Error.new(name: string, message: string, tags: Table?)\n</code></pre> <p>Create an error object with a specified name and message.</p> <p>In native Lua, errors can only be string values. At Roblox, we can take advantage of throwing error objects to provide structured information about problems that occur.</p> <p>The tags table stores rich information about an error which can be provided when it is thrown, and later passed to a logging endpoint.</p> <p>Throwing an error instance captures its stack trace, avoiding the need to explicitly use xpcall.</p> <p>Fields</p> Name Description <code>name: string</code> The name of the error <code>message: string</code> A message which will be formatted with Dash.format if the error is thrown <code>tags: Table</code> A table to store custom rich information about the error <code>stack: string?</code> The value of <code>debug.traceback()</code> when the error is thrown <p>Methods</p> Name Description <code>:joinTags(tags: Table?)</code> Return a new error instance containing the tags provided joined to any existing tags of the current error instance. <code>:throw(tags: Table?)</code> Throw an error.The stack of the error is captured and stored.If tags are provided, a new error is created and thrown with the joined tags of this instance. <p>Static Methods</p> Name Description <code>.new(name: string, message: string, tags: Table?)</code> Returns a new <code>Error</code> instance <code>.is(other: any)</code> Returns <code>true</code> if other is an <code>Error</code> instance <p>Usage</p> <p>In general, errors should not be used during normal control flow.</p>"},{"location":"api/#symbol","title":"Symbol","text":"<p> Classes </p> <p>Create a symbol with a specified name. Upper snake-case is recommended as the symbol is a constant, unless you are linking the symbol conceptually to a different string.</p> <p>Symbols are useful when you want a value that isn't equal to any other type, for example if you want to store a unique property on an object that won't be accidentally accessed with a simple string lookup.</p> <p>Static Methods</p> Name Description <code>.new(name: string)</code> Returns a new unique <code>Symbol</code> instance with called name <code>.is(other: any)</code> Returns <code>true</code> if other is a <code>Symbol</code> instance <p>Example</p> <pre><code>local CHEESE = Symbol.new(\"CHEESE\")\nlocal FAKE_CHEESE = Symbol.new(\"CHEESE\")\nprint(CHEESE == CHEESE) --&gt; true\nprint(CHEESE == FAKE_CHEESE) --&gt; false\nprint(tostring(CHEESE)) --&gt; \"Symbol.new(CHEESE)\"\n</code></pre>"},{"location":"api/#class_1","title":"class","text":"<p> Classes </p> <p>Create a class called name with the specified constructor. The constructor should return a plain table which will be turned into an instance of Class from a call to <code>Class.new(...)</code>.</p> <p>Instance Methods</p> Name Description <code>:toString(): string</code> Returns a string representation of the class <code>:equals(other: any):boolean</code> Returns <code>true</code> if the instance is equal to other <code>:_init()</code> A private function which is called once the instance has been initialized <p>Static Methods</p> Name Description <code>.new(...): Table</code> Returns a new instance of the class <code>.isInstance(value: any): boolean</code> Returns <code>true</code> if value is an instance of the class <p>Examples</p> <pre><code>-- Create a simple Vehicle class\nlocal Vehicle = class(\"Vehicle\", function(wheelCount: number) return\n    {\n        speed = 0,\n        wheelCount = wheelCount\n    }\nend)\nfunction Vehicle:drive(speed)\n    self.speed = speed\nend\n-- Create a car instance\nlocal car = Vehicle.new(4)\ncar.wheelCount --&gt; 4\ncar.speed --&gt; 0\n-- Drive the car\ncar:drive(10)\ncar.speed --&gt; 10\n</code></pre> <p>Usage</p> <ul> <li>When using Dash classes, private fields should be prefixed with <code>_</code> to avoid accidental access.</li> <li>A private field should only be accessed by a method of the class itself, though Dash does not restrict this in code.</li> <li>Public fields are recommended when there is no complex access logic e.g. <code>position.x</code></li> </ul>"},{"location":"api/#symbols","title":"Symbols","text":"<p>Symbol definitions.</p>"},{"location":"api/#none","title":"None","text":"<p> Symbols </p> <p>A symbol representing nothing, that can be used in place of nil as a key or value of a table, where nil is illegal.</p> <p>Utility functions can check for the None symbol and treat it like a nil value.</p> <p>Usage</p> <p>Use cases include:</p> <ol> <li>Creating an ordered list with undefined values in it</li> <li>Creating a map with a key pointing to a nil value</li> </ol>"},{"location":"api/#debugging","title":"Debugging","text":"<p>These utilities assist with debugging Lua code.</p>"},{"location":"api/#assertequal","title":"assertEqual","text":"<p> Debugging | Maps </p> <pre><code>assertEqual(left: any, right: any, formattedErrorMessage: string?): ()\n</code></pre> <p>Performs a simple equality check and throws an error if left is not equal to right.</p> <p>The formatted error message can be customized, which by default provides a serialization of both inputs using Dash.pretty.</p> <p>The <code>left</code> and <code>right</code> values are available to be referenced in the formatted message.</p>"},{"location":"api/#cycles","title":"cycles","text":"<p> Debugging | Tables </p> <pre><code>cycles(value: any, initialCycles: Cycles?): Cycles\n</code></pre> <p>Get information about the number of times references to the same table values appear in a data structure.</p> <p>Operates on cyclic structures, and returns a Cycles object for a given value by walking it recursively.</p> <p>Cycles</p> Name Type Description <code>omit</code> <code>Array&lt;any&gt;</code> An array of keys which should not be visited <code>visited</code> <code>Set&lt;Table&gt;</code> A set of tables which were visited recursively <code>refs</code> <code>Map&lt;Table, number&gt;</code> A map from table to unique index in visit order <code>nextRef</code> <code>number</code> The number to use for the next unique table visited"},{"location":"api/#format","title":"format","text":"<p> Debugging | Strings </p> <pre><code>format(formatString: string, ...): string\n</code></pre> <p>Returns the format string with placeholders <code>{...}</code> substituted with readable representations of the subsequent arguments. This function is a simpler &amp; more powerful version of <code>string.format</code>, inspired by <code>format!</code> in Rust.</p> <ul> <li><code>{}</code> formats and prints the next argument using <code>:format()</code> if available, or a suitable   default representation depending on its type.</li> <li><code>{blah}</code> formats and prints the key \"blah\" of the 1st argument</li> <li><code>{2}</code> formats and prints the 2nd argument.</li> <li><code>{#2}</code> prints the length of the 2nd argument.   Display parameters can be combined after a <code>:</code> in the curly braces. Any format parameters used   in <code>string.format</code> can be used here, along with these extras:</li> <li><code>{:?}</code> formats any value using <code>pretty</code>.</li> <li><code>{:#?}</code> formats any value using multiline <code>pretty</code>.</li> </ul> <p>Examples</p> <pre><code>local props = {\"teeth\", \"claws\", \"whiskers\", \"tail\"}\nformat(\"{} is in {:#?}\", \"whiskers\", props)\n--&gt; [[whiskers is in {\"teeth\", \"claws\", \"whiskers\", \"tail\"}]]\n</code></pre> <pre><code>format(\"The time is {:02}:{:02}\", 2, 4) -&gt; \"The time is 02:04\"\n</code></pre> <pre><code>format(\"The color blue is #{:06X}\", 255) -&gt; \"The color blue is #0000FF\"\n</code></pre> <p>Usage</p> <ul> <li>Escape <code>{</code> with <code>{{</code> and <code>}</code> similarly with <code>}}</code>.</li> <li>See https://developer.roblox.com/articles/Format-String for complete list of formating options and further use cases.</li> </ul>"},{"location":"api/#formatvalue","title":"formatValue","text":"<p> Debugging | Strings </p> <pre><code>formatValue(value: any, displayString: string): string\n</code></pre> <p>Format a specific value using the specified displayString.</p> <p>Examples</p> <pre><code>formatValue(255, \"06X\") --&gt; \"0000FF\"\n</code></pre> <pre><code>formatValue(255.5) --&gt; \"255.5\"\n</code></pre> <p>See</p> <ul> <li>Dash.format - see format for a full description of valid display strings.</li> </ul>"},{"location":"api/#pretty","title":"pretty","text":"<p> Debugging | Tables | Strings </p> <pre><code>pretty(object: any, options: PrettyOptions?): string\n</code></pre> <p>Return a pretty string serialization of object.</p> <p>This implementation deals with cycles in tables and can neatly display metatables.</p> <p>Optionally use an indented multiline string, limit the depth of tables, omit or pick keys.</p> <p>PrettyOptions</p> Name Type Description <code>depth</code> <code>number?</code> The maximum depth of ancestors of a table to display <code>omit</code> <code>Array&lt;any&gt;?</code> An array of keys which should not be visited <code>multiline</code> <code>boolean?</code> Whether to use multiple lines (default = false) <code>noQuotes</code> <code>boolean?</code> Whether to drop the quotation marks around strings. By default, this is true for table keys <code>indent</code> <code>string?</code> The indent string to use (default = \"\\t\") <code>visited</code> <code>Set&lt;Table&gt;?</code> A set of tables which have already been visited and should be referred to by reference <code>cycles</code> <code>Cycles?</code> A cycles object returned from <code>cycles</code> to aid reference display <p>See</p> <ul> <li>Dash.cycles</li> </ul>"}]}